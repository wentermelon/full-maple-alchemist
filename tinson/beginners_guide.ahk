#NoEnv  ; Recommended for performance and compatibility with future AutoHotkey releases.
; #Warn  ; Enable warnings to assist with detecting common errors.
SendMode Input  ; Recommended for new scripts due to its superior speed and reliability.
SetWorkingDir %A_ScriptDir%  ; Ensures a consistent starting directory.

/* 	
	Multi-line comments are denoted by encasement
	with a forward slash asterisk and an asterisk forward slash
*/

; Single line comments are denoted by a semicolon

; Lines 1-4 are boilerplate code generated by ahk scripts; do not modify!

/* 
	Let's review some basic ideas for macros...

	Macros generally consist of a repeated set of actions -> This implies that we will need a loop
	We don't usually pre-determine how long macros are run for...
	They continue to run until we give it a command to stop -> This further implies that the loop will be a while loop
	
	The simplest way to implement a while loop is to set a boolean variable as the control.
	We turn the loop on or off by setting that variable to 1 or 0.
*/

; STEP 1. Initializing a control boolean variable
; The following code creates a variable named 'toggle' and sets it to 1

toggle = 1 

/*
	Next, we'll need a way to map this ability to turn the variable on or off onto a key
	The syntax for this in the AHK language is:
	[Key]::
	Read as, "when this key is pressed, do this"
	Altogether, it'll look something like this
*/

; STEP 2. Implementing a method to control the control boolean variable

F11::
	Send, E
	
	if ( toggle )
		toggle = 0
	else
		toggle = 1
	return
	
; "When F11 is pressed, if toggle is on, turn it off. Else if toggle is off, turn it on. Return control to user from function."
; The "Send, E" part is used diagnostically as a way to let myself know if my macro is on or not - ie. by pressing F11, my equipment window will be open.
; I use this as a tell to show that my toggle is set to active.

/*
	Now that we're able to do that, it's time to actually write the magic!
 	We will be primarily using 3 basic functions in our 'incantation'
 	1. Send, [Key]
	This function sends input to the computer - you can also read this as "Press [Key]"
	2. Sleep [Value]
	This function tells the computer to wait [Value] miliseconds before proceeding with the next command 
	EXAMPLE: Sleep 2000
	EXPLANATION: "Wait 2000 miliseconds before reading in the next command"
	Note that the Send function is followed by a comma while the Sleep function is not. This is important and must always be the case. 
*/


/* 
	The final function ties the above two ideas together
	3a. Send, {[Key down]}
	3b. Sleep [Value]
	3c. Send, {[Key up]}
	This first part of this variation of the Send function tells the computer to "press and hold the key down"
	The second part tells the computer, "hold for [Value] miliseconds"
	Lastly, the key is then lifted up when the corresponding {[key up]} command is issued
	Let's take a look at this in action...
*/


F12::										;When the F12 button is pressed....

	While (toggle == 1) 					;While our control variable is on, execute the following commands
	{
		Send, {Left down}					;Press and hold the left arrow
		Sleep 5000							;Hold it for 5000 miliseconds
		Send, {Left up}						;Let go of the left arrow
		Sleep 100							;Wait 100 miliseconds
		Send, T 							;Press T (in my case, this is my button to use one of my skills, Dark Genesis)
		Sleep 3000							;Wait 3000 miliseconds***
		Send, CTRL							;Press CTRL (this is my button to jump)
	}
	return									;Return control to the user
	

/*
	NOTE: A lot of the attack commands should be followed by 'Sleep [Value]'. 
	This is because inputs are registered extremely quickly by a computer. 
	Sometimes, skills have long animations that render your character unable to act until a certain period of time is over.
	By interlacing our code with numerous Sleep commands, we account for these delays AND provide a buffer that deals with server lag.
	
	EXAMPLE: My Dark Genesis has a skill animation that lasts for a good ~2 seconds. I'm unable to move my character during cast.
	EXPLANATION: Because the computer will continue to read in commands, I throw in Sleep 3000 to account for that skill animation, and tell the computer to wait
					1000 extra miliseconds to ensure that my character is able to act again before issuing the next command, which is to jump
					
*/

/* 
	One final thing to add is the inclusion of break conditions.
	I mentioned above that ideally, we'd like to exit out of a macro by setting the toggle variable to off.
	In the case we've constructed above, the while loop executed by pressing F12 will continue to run until toggle is no longer equal to 1.
	We can set toggle equal to 0 by pressing F11 again.
	However, what if I press F11 as soon as the Send, {Left down} command is read?
	Well, toggle is set to 0 surely enough, but the rest of the while loop executes until it reaches the end.
	When it reaches the end, the computer will re-evaluate the loop condition: "Is toggle equal to 1?"
	It will arrive at "no", for an answer, and then exit from the loop.
	
	This means that the loop will continue to run one full iteration even though we've asked it to stop awhile ago.
	To improve responsiveness of these loops, we throw in break conditions - ie. certain conditions that, when encountered within the loop, causes 
	the computer to break out of the while loop immediately.
	Then, revising our previous loop...
*/ 

F12::
	
	While (toggle == 1)
	{
		Send, {Left down}
		Sleep 5000
		
		if (toggle == 0)
			break
			
		Send {Left up}
		Sleep 100
		Send, T
		
		if (toggle == 0)
			break
	
		Sleep 3000
		Send, CTRL
	}
	return
	
/* 
	Our new code now has set two break points in the loop. 
	This means that there are now THREE INSTANCES when our code checks to see if we've turned off toggle.
	Once, after holding down left for 5 seconds.
	A second time after casing Dark Genesis.
	A third and final time when one full iteration of the loop is completed.
	
	This lets our program be more responsive and ready to exit as we will it.
*/

/* 
	That should be about it as far as basics go.
	Ideas like modularizing and writing seperate functions that may be repeated and called upon to reduce redundant code are nice and can be a point of improvement,
	if you so wish to include it in your 'formulations'. (I would suggest that you do, although it isn't the end of the world if you don't!)
	
	Okay, you are now a fully capable magician.
	Go out there and create wonderful magic for the world to (hopefully) not see!
*/
	